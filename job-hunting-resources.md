# Resume Advice

- **[A short slide show about CS resumes](http://www.cs.usfca.edu/~parrt/doc/resume.pdf)**
- **[Building a Resume](https://www.reddit.com/r/resumes/wiki/faq#wiki_building_a_resume)**
- Consider using a json resume to conveniently present your resume as text, pdf, html etc. You can easily [generate json here](http://registry.jsonresume.org/) and use either the online editor or the command line tool to try out different themes.
- **[Get feedback on your resume here](reddit.com/r/resumes)**

# Interview Prep
- **Algorithms**
[Binary Search](https://en.wikipedia.org/wiki/Binary_search_algorithm)
[Merge Sort](https://en.wikipedia.org/wiki/Merge_sort)
[Quick Sort](https://en.wikipedia.org/wiki/Quicksort)
[Dijkstras](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
[Tree Traversal](https://en.wikipedia.org/wiki/Tree_traversal)
[Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search)
[Breadth First Search](https://en.wikipedia.org/wiki/Breadth-first_search)

For interview purposes you should be able to:
Briefly describe how they work
Write a pseudocode version
Know when to use it
Know the running time and space complexity (Big O)
Be able to implement a working version
Be familiar with it's pro's and cons and optimizations, even if you can't implement them. eg: Quicksort can be improved by chosing the pivot at random, merge sort can be done back and forth between two arrays in order to save space.

- **Datastructures **
[Array](https://en.wikipedia.org/wiki/Array_data_structure)
[Linked List](https://en.wikipedia.org/wiki/Linked_list)
[Hash Table](https://en.wikipedia.org/wiki/Hash_table)
[Binary Tree](https://en.wikipedia.org/wiki/Binary_tree)
[Stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))
[Queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))
[Priority Queue](https://en.wikipedia.org/wiki/Priority_queue)
[Prefix Tree](https://en.wikipedia.org/wiki/Trie)
[Graph](https://en.wikipedia.org/wiki/Graph_(abstract_data_type))

For interview purposes you should be able to:

Briefly describe how they work
Write a pseudocode version
Know when to use it
Know the interface (eg: adding, removing, or finding elements)
Know the running time of the interface methods (Big O)
Know the underlying representation in memory (eg: a hash table stores values in an array)
Be able to implement a working version
Be familiar with it's pro's and cons and optimizations, even if you can't implement them. eg: Two ways to handle collisions when adding items to a hash table.

- **Whiteboarding (talk, explain your thought process. PRACTICE)**
- **Pseudocode/coding without an editor**
- **HackerRank type platforms**
- **General outline of interview structure **(phone screen, technical phone screen, onsite, take home coding challenge)
- **[Salary Negotiation](http://www.kalzumeus.com/2012/01/23/salary-negotiation/)**
- **[Realities Of Your Industry 101](http://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer/)**

# Portfolio

# Contribute to Open Source
- **Why**
- **How to choose an OSS project to work on**

# Network
- **Your programmer friends and aquaintences**
- **Meetups**
- **Bootcamps as networking**
- **Networking is not a dirty word. Men vs Women views on networking.**

# Internships
- **[Outreachy](https://www.gnome.org/outreachy/)** - Outreachy helps people from groups underrepresented in free and open source software get involved. We provide a supportive community for beginning to contribute any time throughout the year and offer focused internship opportunities twice a year with a number of free software organizations.

- **[Google Summer of Code](https://www.google-melange.com/gsoc/homepage/google/gsoc2015)** - Google Summer of Code is a global program that offers students stipends to write code for open source projects. We have worked with the open source community to identify and fund exciting projects for the upcoming summer.









